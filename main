<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Zen Snake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg-color: #050505;
            --grid-color: #0a0a0a;
            --snake-color: #39ff14;
            --snake-glow: 0 0 10px #39ff14, 0 0 20px #39ff14;
            --food-color: #ff0055;
            --food-glow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            --text-color: #00f3ff;
            --text-glow: 0 0 5px #00f3ff;
            --border-color: #00f3ff;
            --border-glow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            border: 2px solid var(--border-color);
            box-shadow: var(--border-glow);
            background: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: rgba(5, 5, 5, 0.9);
            transition: border-color 0.3s;
        }

        @keyframes pulse-border {
            0% { box-shadow: 0 0 10px rgba(0, 243, 255, 0.2); }
            50% { box-shadow: 0 0 25px rgba(0, 243, 255, 0.6); }
            100% { box-shadow: 0 0 10px rgba(0, 243, 255, 0.2); }
        }

        #game-container.active {
            animation: pulse-border 2s infinite;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .score-board {
            font-size: 24px;
            text-shadow: var(--text-glow);
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 25px;
            border: 1px solid var(--border-color);
            box-shadow: 0 0 15px var(--border-color);
            z-index: 20;
            width: 85%;
            max-width: 320px;
            border-radius: 4px;
        }

        h1 {
            margin: 0 0 10px 0;
            color: var(--snake-color);
            text-shadow: var(--snake-glow);
            font-size: 42px;
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1;
        }
        
        h2 {
            margin: -5px 0 15px 0;
            font-size: 18px;
            color: #fff;
            opacity: 0.8;
            letter-spacing: 4px;
            font-weight: normal;
        }

        p {
            font-size: 18px;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        button {
            background: rgba(0, 243, 255, 0.1);
            color: var(--text-color);
            border: 1px solid var(--text-color);
            padding: 12px 25px;
            font-family: 'VT323', monospace;
            font-size: 22px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 5px var(--text-color);
            transition: all 0.2s;
        }

        button:hover {
            background: var(--text-color);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--text-color);
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.3;
        }

        #mobile-controls {
            display: none;
            margin-top: 20px;
            width: 100%;
            justify-content: center;
            gap: 20px;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .dpad-row {
                display: flex;
                gap: 15px;
            }
            .dpad-btn {
                width: 65px;
                height: 65px;
                border: 2px solid var(--text-color);
                background: rgba(0, 243, 255, 0.05);
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 28px;
                color: var(--text-color);
                text-shadow: var(--text-glow);
                user-select: none;
                -webkit-user-select: none;
                box-shadow: 0 0 5px rgba(0, 243, 255, 0.2);
            }
            .dpad-btn:active {
                background: var(--text-color);
                color: black;
                text-shadow: none;
            }
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="game-container">
        <div id="ui-layer">
            <div class="score-board">SCORE: <span id="score">0</span></div>
            <div class="score-board">HI: <span id="high-score">0</span></div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="start-screen">
            <h1>NEON SNAKE</h1>
            <h2>ZEN MODE</h2>
            <p>Infinite Walls.<br>Invincible Tail.</p>
            <button id="start-btn">INITIALIZE</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1 id="end-title">GAME OVER</h1>
            <p>Score: <span id="final-score">0</span></p>
            <button id="restart-btn">REBOOT</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="dpad-row">
            <div class="dpad-btn" data-dir="up">▲</div>
        </div>
        <div class="dpad-row">
            <div class="dpad-btn" data-dir="left">◀</div>
            <div class="dpad-btn" data-dir="down">▼</div>
            <div class="dpad-btn" data-dir="right">▶</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('high-score');
    const finalScoreElement = document.getElementById('final-score');
    const endTitleElement = document.getElementById('end-title');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const container = document.getElementById('game-container');

    const GRID_SIZE = 20;
    let TILE_COUNT_X = 20;
    let TILE_COUNT_Y = 20;
    
    const COLOR_SNAKE = '#39ff14';
    const COLOR_FOOD = '#ff0055';
    const SHADOW_BLUR = 15;

    let snake = [];
    let food = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };
    let nextVelocity = { x: 0, y: 0 };
    let score = 0;
    let highScore = localStorage.getItem('snakeZenHighScore') || 0;
    let gameInterval;
    let gameSpeed = 90;
    let isGameRunning = false;

    highScoreElement.innerText = highScore;

    function resizeGame() {
        const maxWidth = Math.min(window.innerWidth - 20, 600);
        const maxHeight = Math.min(window.innerHeight - 200, 600); 

        const cols = Math.floor(maxWidth / GRID_SIZE);
        const rows = Math.floor(maxHeight / GRID_SIZE);

        canvas.width = cols * GRID_SIZE;
        canvas.height = rows * GRID_SIZE;

        TILE_COUNT_X = cols;
        TILE_COUNT_Y = rows;
    }

    window.addEventListener('resize', resizeGame);
    resizeGame();

    function initGame() {
        snake = [
            { x: Math.floor(TILE_COUNT_X / 2), y: Math.floor(TILE_COUNT_Y / 2) },
            { x: Math.floor(TILE_COUNT_X / 2), y: Math.floor(TILE_COUNT_Y / 2) + 1 },
            { x: Math.floor(TILE_COUNT_X / 2), y: Math.floor(TILE_COUNT_Y / 2) + 2 }
        ];
        velocity = { x: 0, y: -1 };
        nextVelocity = { x: 0, y: -1 };
        score = 0;
        scoreElement.innerText = score;
        placeFood();
        isGameRunning = true;
        
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, gameSpeed);
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        container.classList.add('active');
    }

    function placeFood() {
        // Safety: If snake fills screen, user wins
        if (snake.length >= TILE_COUNT_X * TILE_COUNT_Y - 1) {
            endGame(true);
            return;
        }

        let valid = false;
        // Avoid infinite loop if screen is very full by adding a counter
        let attempts = 0;
        
        while (!valid && attempts < 500) {
            food.x = Math.floor(Math.random() * TILE_COUNT_X);
            food.y = Math.floor(Math.random() * TILE_COUNT_Y);
            
            valid = true;
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    valid = false;
                    break;
                }
            }
            attempts++;
        }
        
        // If random placement fails due to crowding, search linearly
        if (!valid) {
            for (let y = 0; y < TILE_COUNT_Y; y++) {
                for (let x = 0; x < TILE_COUNT_X; x++) {
                    let occupied = false;
                    for (let segment of snake) {
                        if (segment.x === x && segment.y === y) {
                            occupied = true;
                            break;
                        }
                    }
                    if (!occupied) {
                        food.x = x;
                        food.y = y;
                        return;
                    }
                }
            }
        }
    }

    function gameLoop() {
        update();
        draw();
    }

    function update() {
        if (!isGameRunning) return;

        velocity = { ...nextVelocity };
        let head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

        // --- INFINITY LOOP LOGIC ---
        if (head.x < 0) {
            head.x = TILE_COUNT_X - 1;
        } else if (head.x >= TILE_COUNT_X) {
            head.x = 0;
        }

        if (head.y < 0) {
            head.y = TILE_COUNT_Y - 1;
        } else if (head.y >= TILE_COUNT_Y) {
            head.y = 0;
        }

        // --- REMOVED SELF COLLISION CHECK ---
        // The snake simply passes through itself now.
        // ------------------------------------

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
            score += 10;
            scoreElement.innerText = score;
            if (score % 100 === 0 && gameSpeed > 40) {
                clearInterval(gameInterval);
                gameSpeed -= 5;
                gameInterval = setInterval(gameLoop, gameSpeed);
            }
            placeFood();
        } else {
            snake.pop();
        }
    }

    function draw() {
        ctx.fillStyle = 'rgba(5, 5, 5, 1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Food
        ctx.fillStyle = COLOR_FOOD;
        ctx.shadowBlur = SHADOW_BLUR;
        ctx.shadowColor = COLOR_FOOD;
        ctx.fillRect(food.x * GRID_SIZE + 2, food.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);

        // Draw Snake
        ctx.shadowBlur = SHADOW_BLUR;
        ctx.shadowColor = COLOR_SNAKE;
        
        snake.forEach((segment, index) => {
            ctx.fillStyle = COLOR_SNAKE;
            if (index === 0) ctx.fillStyle = '#ccffcc'; 
            ctx.fillRect(segment.x * GRID_SIZE + 1, segment.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
        });

        ctx.shadowBlur = 0;
    }

    function endGame(win) {
        isGameRunning = false;
        clearInterval(gameInterval);
        container.classList.remove('active');
        
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('snakeZenHighScore', highScore);
            highScoreElement.innerText = highScore;
        }
        
        finalScoreElement.innerText = score;
        endTitleElement.innerText = win ? "SYSTEM CONQUERED" : "GAME OVER";
        if (win) {
            endTitleElement.style.color = COLOR_SNAKE;
        } else {
            endTitleElement.style.color = COLOR_FOOD; // Red for loss
        }
        gameOverScreen.classList.remove('hidden');
    }

    function handleInput(key) {
        if (!isGameRunning) return;

        switch(key) {
            case 'ArrowUp':
            case 'up':
                if (velocity.y !== 1) nextVelocity = { x: 0, y: -1 };
                break;
            case 'ArrowDown':
            case 'down':
                if (velocity.y !== -1) nextVelocity = { x: 0, y: 1 };
                break;
            case 'ArrowLeft':
            case 'left':
                if (velocity.x !== 1) nextVelocity = { x: -1, y: 0 };
                break;
            case 'ArrowRight':
            case 'right':
                if (velocity.x !== -1) nextVelocity = { x: 1, y: 0 };
                break;
        }
    }

    document.addEventListener('keydown', (e) => {
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
            e.preventDefault();
        }
        handleInput(e.key);
    });

    let touchStartX = 0;
    let touchStartY = 0;

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, {passive: false});

    document.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].screenX;
        const touchEndY = e.changedTouches[0].screenY;
        handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
    }, {passive: false});

    function handleSwipe(startX, startY, endX, endY) {
        const diffX = endX - startX;
        const diffY = endY - startY;
        
        if (Math.abs(diffX) < 30 && Math.abs(diffY) < 30) return;

        if (Math.abs(diffX) > Math.abs(diffY)) {
            handleInput(diffX > 0 ? 'ArrowRight' : 'ArrowLeft');
        } else {
            handleInput(diffY > 0 ? 'ArrowDown' : 'ArrowUp');
        }
    }

    document.querySelectorAll('.dpad-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput(btn.dataset.dir);
        });
        btn.addEventListener('mousedown', (e) => {
            handleInput(btn.dataset.dir);
        });
    });

    startBtn.addEventListener('click', initGame);
    restartBtn.addEventListener('click', initGame);

    ctx.fillStyle = 'rgba(5, 5, 5, 1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

</script>
</body>
</html>
